"""
2022-03-26 15:40:49
AC
1.0
Accepted | 1 * (5 / 100) | 2 ms | 1636 KB
Accepted | 1 * (35 / 100) | 2 ms | 1484 KB
Accepted | 1 * (60 / 100) | 2 ms | 1592 KB

"""

#include <stdio.h>
#include <stdlib.h>
int main()
{
    int T, num;
    scanf("%d", &T);
    while (T--)
    {
        scanf("%d", &num);
        int ans = (num == 1) ? 0 : 1; //为什么初始值为零，因为1肯定是所有数的真因子(除非这个数本来是1)
        for (int i = 2; i * i <= num; i++)  //这样的话就可以直接从2开始枚举
        { 
            //当然也不用枚举到num，其实到sqrt(num)就可以
            //因为如果找到一个数i是他的因子的话，那么num/i也一定是它的真因子，一次其实能找到两个
            //而当i<sqrt(num)的时候，num/i一定是要大于sqrt(num)的，这样正好把另一半找完了
            if (num % i == 0)
                ans += i + num / i; //每次加一对而不是一个
        }
        if (num == ans)
            puts("YES");
        else
            puts("NO");
    }
    return 0;
}
/*
来聊聊为什么要这么干，这实际上是一个卡时间的事情
比如说按照你那么写，如果数据有1000组，而每一组给你的数最大能达到10^6的话
按照你那么写，那么最坏会枚举1000*10^6=10^9次，这绝对会超时
而如果只找到sqrt(n)的话，即使是数大到10^6,那么实际枚举的也只有前10^3的数
这样算下来一共会枚举1000*10^3=10^6次，和上面比是不是就小了很多很多hhhh
小技巧，在求质数的时候也可以这么干，可以积累一下

当然这个题作为签到题，数据范围很水，咋写都行 qwq
*/